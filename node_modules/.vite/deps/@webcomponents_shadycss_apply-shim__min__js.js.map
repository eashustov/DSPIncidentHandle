{
  "version": 3,
  "sources": ["../../@webcomponents/shadycss/src/style-settings.js", "../../@webcomponents/shadycss/src/css-parse.js", "../../@webcomponents/shadycss/src/common-regex.js", "../../@webcomponents/shadycss/src/unscoped-style-handler.js", "../../@webcomponents/shadycss/src/style-util.js", "../../@webcomponents/shadycss/src/apply-shim.js", "../../@webcomponents/shadycss/src/common-utils.js", "../../@webcomponents/shadycss/src/template-map.js", "../../@webcomponents/shadycss/src/apply-shim-utils.js", "../../@webcomponents/shadycss/entrypoints/apply-shim.js"],
  "sourcesContent": ["/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nexport const nativeShadow = !(\n  window['ShadyDOM'] && window['ShadyDOM']['inUse']\n);\n/** @type {boolean} */\nlet nativeCssVariables_;\n\n/**\n * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings\n */\nfunction calcCssVariables(settings) {\n  if (settings && settings.shimcssproperties) {\n    nativeCssVariables_ = false;\n  } else {\n    // chrome 49 has semi-working css vars, check if box-shadow works\n    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782\n    // However, shim css custom properties are only supported with ShadyDOM enabled,\n    // so fall back on native if we do not detect ShadyDOM\n    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/\n    nativeCssVariables_ =\n      nativeShadow ||\n      Boolean(\n        !navigator.userAgent.match(/AppleWebKit\\/601|Edge\\/15/) &&\n          window.CSS &&\n          CSS.supports &&\n          CSS.supports('box-shadow', '0 0 0 var(--foo)')\n      );\n  }\n}\n\n/** @type {string | undefined} */\nexport let cssBuild;\nif (window.ShadyCSS && window.ShadyCSS.cssBuild !== undefined) {\n  cssBuild = window.ShadyCSS.cssBuild;\n}\n\n/** @type {boolean} */\nexport const disableRuntime = Boolean(\n  window.ShadyCSS && window.ShadyCSS.disableRuntime\n);\n\nif (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {\n  nativeCssVariables_ = window.ShadyCSS.nativeCss;\n} else if (window.ShadyCSS) {\n  calcCssVariables(window.ShadyCSS);\n  // reset window variable to let ShadyCSS API take its place\n  window.ShadyCSS = undefined;\n} else {\n  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);\n}\n\n// Hack for type error under new type inference which doesn't like that\n// nativeCssVariables is updated in a function and assigns the type\n// `function(): ?` instead of `boolean`.\nexport const nativeCssVariables = /** @type {boolean} */ (nativeCssVariables_);\n", "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/*\nExtremely simple css parser. Intended to be not more than what we need\nand definitely not necessarily correct =).\n*/\n\n'use strict';\n\n/** @unrestricted */\nclass StyleNode {\n  constructor() {\n    /** @type {number} */\n    this['start'] = 0;\n    /** @type {number} */\n    this['end'] = 0;\n    /** @type {StyleNode} */\n    this['previous'] = null;\n    /** @type {StyleNode} */\n    this['parent'] = null;\n    /** @type {Array<StyleNode>} */\n    this['rules'] = null;\n    /** @type {string} */\n    this['parsedCssText'] = '';\n    /** @type {string} */\n    this['cssText'] = '';\n    /** @type {boolean} */\n    this['atRule'] = false;\n    /** @type {number} */\n    this['type'] = 0;\n    /** @type {string} */\n    this['keyframesName'] = '';\n    /** @type {string} */\n    this['selector'] = '';\n    /** @type {string} */\n    this['parsedSelector'] = '';\n  }\n}\n\nexport {StyleNode};\n\n// given a string of css, return a simple rule tree\n/**\n * @param {string} text\n * @return {StyleNode}\n */\nexport function parse(text) {\n  text = clean(text);\n  return parseCss(lex(text), text);\n}\n\n// remove stuff we don't care about that may hinder parsing\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction clean(cssText) {\n  return cssText.replace(RX.comments, '').replace(RX.port, '');\n}\n\n// super simple {...} lexer that returns a node tree\n/**\n * @param {string} text\n * @return {!StyleNode}\n */\nfunction lex(text) {\n  let root = new StyleNode();\n  root['start'] = 0;\n  root['end'] = text.length;\n  let n = root;\n  for (let i = 0, l = text.length; i < l; i++) {\n    if (text[i] === OPEN_BRACE) {\n      if (!n['rules']) {\n        n['rules'] = [];\n      }\n      let p = n;\n      let previous = p['rules'][p['rules'].length - 1] || null;\n      n = new StyleNode();\n      n['start'] = i + 1;\n      n['parent'] = p;\n      n['previous'] = previous;\n      p['rules'].push(n);\n    } else if (text[i] === CLOSE_BRACE) {\n      n['end'] = i + 1;\n      n = n['parent'] || root;\n    }\n  }\n  return root;\n}\n\n// add selectors/cssText to node tree\n/**\n * @param {StyleNode} node\n * @param {string} text\n * @return {!StyleNode}\n */\nfunction parseCss(node, text) {\n  let t = text.substring(node['start'], node['end'] - 1);\n  node['parsedCssText'] = node['cssText'] = t.trim();\n  if (node['parent']) {\n    let ss = node['previous']\n      ? node['previous']['end']\n      : node['parent']['start'];\n    t = text.substring(ss, node['start'] - 1);\n    t = _expandUnicodeEscapes(t);\n    t = t.replace(RX.multipleSpaces, ' ');\n    // TODO(sorvell): ad hoc; make selector include only after last ;\n    // helps with mixin syntax\n    t = t.substring(t.lastIndexOf(';') + 1);\n    let s = (node['parsedSelector'] = node['selector'] = t.trim());\n    node['atRule'] = s.indexOf(AT_START) === 0;\n    // note, support a subset of rule types...\n    if (node['atRule']) {\n      if (s.indexOf(MEDIA_START) === 0) {\n        node['type'] = types.MEDIA_RULE;\n      } else if (s.match(RX.keyframesRule)) {\n        node['type'] = types.KEYFRAMES_RULE;\n        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();\n      }\n    } else {\n      if (s.indexOf(VAR_START) === 0) {\n        node['type'] = types.MIXIN_RULE;\n      } else {\n        node['type'] = types.STYLE_RULE;\n      }\n    }\n  }\n  let r$ = node['rules'];\n  if (r$) {\n    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n      parseCss(r, text);\n    }\n  }\n  return node;\n}\n\n/**\n * conversion of sort unicode escapes with spaces like `\\33 ` (and longer) into\n * expanded form that doesn't require trailing space `\\000033`\n * @param {string} s\n * @return {string}\n */\nfunction _expandUnicodeEscapes(s) {\n  return s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\n    let code = arguments[1],\n      repeat = 6 - code.length;\n    while (repeat--) {\n      code = '0' + code;\n    }\n    return '\\\\' + code;\n  });\n}\n\n/**\n * stringify parsed css.\n * @param {StyleNode} node\n * @param {boolean=} preserveProperties\n * @param {string=} text\n * @return {string}\n */\nexport function stringify(node, preserveProperties, text = '') {\n  // calc rule cssText\n  let cssText = '';\n  if (node['cssText'] || node['rules']) {\n    let r$ = node['rules'];\n    if (r$ && !_hasMixinRules(r$)) {\n      for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n        cssText = stringify(r, preserveProperties, cssText);\n      }\n    } else {\n      cssText = preserveProperties\n        ? node['cssText']\n        : removeCustomProps(node['cssText']);\n      cssText = cssText.trim();\n      if (cssText) {\n        cssText = '  ' + cssText + '\\n';\n      }\n    }\n  }\n  // emit rule if there is cssText\n  if (cssText) {\n    if (node['selector']) {\n      text += node['selector'] + ' ' + OPEN_BRACE + '\\n';\n    }\n    text += cssText;\n    if (node['selector']) {\n      text += CLOSE_BRACE + '\\n\\n';\n    }\n  }\n  return text;\n}\n\n/**\n * @param {Array<StyleNode>} rules\n * @return {boolean}\n */\nfunction _hasMixinRules(rules) {\n  let r = rules[0];\n  return (\n    Boolean(r) &&\n    Boolean(r['selector']) &&\n    r['selector'].indexOf(VAR_START) === 0\n  );\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomProps(cssText) {\n  cssText = removeCustomPropAssignment(cssText);\n  return removeCustomPropApply(cssText);\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nexport function removeCustomPropAssignment(cssText) {\n  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');\n}\n\n/**\n * @param {string} cssText\n * @return {string}\n */\nfunction removeCustomPropApply(cssText) {\n  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');\n}\n\n/** @enum {number} */\nexport const types = {\n  STYLE_RULE: 1,\n  KEYFRAMES_RULE: 7,\n  MEDIA_RULE: 4,\n  MIXIN_RULE: 1000,\n};\n\nconst OPEN_BRACE = '{';\nconst CLOSE_BRACE = '}';\n\n// helper regexp's\nconst RX = {\n  comments: /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//gim,\n  port: /@import[^;]*;/gim,\n  customProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\n  mixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\n  mixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\n  varApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\n  keyframesRule: /^@[^\\s]*keyframes/,\n  multipleSpaces: /\\s+/g,\n};\n\nconst VAR_START = '--';\nconst MEDIA_START = '@media';\nconst AT_START = '@';\n", "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nexport const VAR_ASSIGN = /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};{])+)|\\{([^}]*)\\}(?:(?=[;\\s}])|$))/gi;\nexport const MIXIN_MATCH = /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi;\nexport const VAR_CONSUMED = /(--[\\w-]+)\\s*([:,;)]|$)/gi;\nexport const ANIMATION_MATCH = /(animation\\s*:)|(animation-name\\s*:)/;\nexport const MEDIA_MATCH = /@media\\s(.*)/;\nexport const IS_VAR = /^--/;\nexport const BRACKETED = /\\{[^}]*\\}/g;\nexport const HOST_PREFIX = '(?:^|[^.#[:])';\nexport const HOST_SUFFIX = '($|[.:[\\\\s>+~])';\n", "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\n/** @type {!Set<string>} */\nconst styleTextSet = new Set();\n\nexport const scopingAttribute = 'shady-unscoped';\n\n/**\n * Add a specifically-marked style to the document directly, and only one copy of that style.\n *\n * @param {!HTMLStyleElement} style\n * @return {undefined}\n */\nexport function processUnscopedStyle(style) {\n  const text = style.textContent;\n  if (!styleTextSet.has(text)) {\n    styleTextSet.add(text);\n    const newStyle = document.createElement('style');\n    newStyle.setAttribute('shady-unscoped', '');\n    newStyle.textContent = text;\n    document.head.appendChild(newStyle);\n  }\n}\n\n/**\n * Check if a style is supposed to be unscoped\n * @param {!HTMLStyleElement} style\n * @return {boolean} true if the style has the unscoping attribute\n */\nexport function isUnscopedStyle(style) {\n  return style.hasAttribute(scopingAttribute);\n}\n", "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {nativeShadow, nativeCssVariables, cssBuild} from './style-settings.js';\nimport {parse, stringify, types, StyleNode} from './css-parse.js'; // eslint-disable-line @typescript-eslint/no-unused-vars\nimport {MEDIA_MATCH} from './common-regex.js';\n// prettier-ignore\nimport {processUnscopedStyle, isUnscopedStyle} from './unscoped-style-handler.js';\n\n/**\n * @param {string|StyleNode} rules\n * @param {function(StyleNode)=} callback\n * @return {string}\n */\nexport function toCssText(rules, callback) {\n  if (!rules) {\n    return '';\n  }\n  if (typeof rules === 'string') {\n    rules = parse(rules);\n  }\n  if (callback) {\n    forEachRule(rules, callback);\n  }\n  return stringify(rules, nativeCssVariables);\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @return {StyleNode}\n */\nexport function rulesForStyle(style) {\n  if (!style['__cssRules'] && style.textContent) {\n    style['__cssRules'] = parse(style.textContent);\n  }\n  return style['__cssRules'] || null;\n}\n\n// Tests if a rule is a keyframes selector, which looks almost exactly\n// like a normal selector but is not (it has nothing to do with scoping\n// for example).\n/**\n * @param {StyleNode} rule\n * @return {boolean}\n */\nexport function isKeyframesSelector(rule) {\n  return (\n    Boolean(rule['parent']) && rule['parent']['type'] === types.KEYFRAMES_RULE\n  );\n}\n\n/**\n * @param {StyleNode} node\n * @param {Function=} styleRuleCallback\n * @param {Function=} keyframesRuleCallback\n * @param {boolean=} onlyActiveRules\n */\nexport function forEachRule(\n  node,\n  styleRuleCallback,\n  keyframesRuleCallback,\n  onlyActiveRules\n) {\n  if (!node) {\n    return;\n  }\n  let skipRules = false;\n  let type = node['type'];\n  if (onlyActiveRules) {\n    if (type === types.MEDIA_RULE) {\n      let matchMedia = node['selector'].match(MEDIA_MATCH);\n      if (matchMedia) {\n        // if rule is a non matching @media rule, skip subrules\n        if (!window.matchMedia(matchMedia[1]).matches) {\n          skipRules = true;\n        }\n      }\n    }\n  }\n  if (type === types.STYLE_RULE) {\n    styleRuleCallback(node);\n  } else if (keyframesRuleCallback && type === types.KEYFRAMES_RULE) {\n    keyframesRuleCallback(node);\n  } else if (type === types.MIXIN_RULE) {\n    skipRules = true;\n  }\n  let r$ = node['rules'];\n  if (r$ && !skipRules) {\n    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\n      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n    }\n  }\n}\n\n// add a string of cssText to the document.\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @param {Node} target\n * @param {Node} contextNode\n * @return {HTMLStyleElement}\n */\nexport function applyCss(cssText, moniker, target, contextNode) {\n  let style = createScopeStyle(cssText, moniker);\n  applyStyle(style, target, contextNode);\n  return style;\n}\n\n/**\n * @param {string} cssText\n * @param {string} moniker\n * @return {!HTMLStyleElement}\n */\nexport function createScopeStyle(cssText, moniker) {\n  let style = /** @type {HTMLStyleElement} */ (document.createElement('style'));\n  if (moniker) {\n    style.setAttribute('scope', moniker);\n  }\n  style.textContent = cssText;\n  return style;\n}\n\n/**\n * Track the position of the last added style for placing placeholders\n * @type {Node}\n */\nlet lastHeadApplyNode = null;\n\n// insert a comment node as a styling position placeholder.\n/**\n * @param {string} moniker\n * @return {!Comment}\n */\nexport function applyStylePlaceHolder(moniker) {\n  let placeHolder = document.createComment(\n    ' Shady DOM styles for ' + moniker + ' '\n  );\n  let after = lastHeadApplyNode ? lastHeadApplyNode['nextSibling'] : null;\n  let scope = document.head;\n  scope.insertBefore(placeHolder, after || scope.firstChild);\n  lastHeadApplyNode = placeHolder;\n  return placeHolder;\n}\n\n/**\n * @param {HTMLStyleElement} style\n * @param {?Node} target\n * @param {?Node} contextNode\n */\nexport function applyStyle(style, target, contextNode) {\n  target = target || document.head;\n  let after = (contextNode && contextNode.nextSibling) || target.firstChild;\n  target.insertBefore(style, after);\n  if (!lastHeadApplyNode) {\n    lastHeadApplyNode = style;\n  } else {\n    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode\n    let position = style.compareDocumentPosition(lastHeadApplyNode);\n    if (position === Node.DOCUMENT_POSITION_PRECEDING) {\n      lastHeadApplyNode = style;\n    }\n  }\n}\n\n/**\n * @param {string} buildType\n * @return {boolean}\n */\nexport function isTargetedBuild(buildType) {\n  return nativeShadow ? buildType === 'shadow' : buildType === 'shady';\n}\n\n/**\n * Walk from text[start] matching parens and\n * returns position of the outer end paren\n * @param {string} text\n * @param {number} start\n * @return {number}\n */\nexport function findMatchingParen(text, start) {\n  let level = 0;\n  for (let i = start, l = text.length; i < l; i++) {\n    if (text[i] === '(') {\n      level++;\n    } else if (text[i] === ')') {\n      if (--level === 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n\n/**\n * @param {string} str\n * @param {function(string, string, string, string)} callback\n */\nexport function processVariableAndFallback(str, callback) {\n  // find 'var('\n  let start = str.indexOf('var(');\n  if (start === -1) {\n    // no var?, everything is prefix\n    return callback(str, '', '', '');\n  }\n  //${prefix}var(${inner})${suffix}\n  let end = findMatchingParen(str, start + 3);\n  let inner = str.substring(start + 4, end);\n  let prefix = str.substring(0, start);\n  // suffix may have other variables\n  let suffix = processVariableAndFallback(str.substring(end + 1), callback);\n  let comma = inner.indexOf(',');\n  // value and fallback args should be trimmed to match in property lookup\n  if (comma === -1) {\n    // variable, no fallback\n    return callback(prefix, inner.trim(), '', suffix);\n  }\n  // var(${value},${fallback})\n  let value = inner.substring(0, comma).trim();\n  let fallback = inner.substring(comma + 1).trim();\n  return callback(prefix, value, fallback, suffix);\n}\n\n/**\n * @param {Element} element\n * @param {string} value\n */\nexport function setElementClassRaw(element, value) {\n  // use native setAttribute provided by ShadyDOM when setAttribute is patched\n  if (nativeShadow) {\n    element.setAttribute('class', value);\n  } else {\n    window['ShadyDOM']['nativeMethods']['setAttribute'].call(\n      element,\n      'class',\n      value\n    );\n  }\n}\n\n/**\n * @type {function(*):*}\n */\nexport const wrap =\n  (window['ShadyDOM'] && window['ShadyDOM']['wrap']) || ((node) => node);\n\n/**\n * @param {Element | {is: string, extends: string}} element\n * @return {{is: string, typeExtension: string}}\n */\nexport function getIsExtends(element) {\n  let localName = element['localName'];\n  let is = '',\n    typeExtension = '';\n  /*\n  NOTE: technically, this can be wrong for certain svg elements\n  with `-` in the name like `<font-face>`\n  */\n  if (localName) {\n    if (localName.indexOf('-') > -1) {\n      is = localName;\n    } else {\n      typeExtension = localName;\n      is = (element.getAttribute && element.getAttribute('is')) || '';\n    }\n  } else {\n    is = /** @type {?} */ (element).is;\n    typeExtension = /** @type {?} */ (element).extends;\n  }\n  return {is, typeExtension};\n}\n\n/**\n * @param {Element|DocumentFragment} element\n * @return {string}\n */\nexport function gatherStyleText(element) {\n  /** @type {!Array<string>} */\n  const styleTextParts = [];\n  const styles = /** @type {!NodeList<!HTMLStyleElement>} */ (element.querySelectorAll(\n    'style'\n  ));\n  for (let i = 0; i < styles.length; i++) {\n    const style = styles[i];\n    if (isUnscopedStyle(style)) {\n      if (!nativeShadow) {\n        processUnscopedStyle(style);\n        style.parentNode.removeChild(style);\n      }\n    } else {\n      styleTextParts.push(style.textContent);\n      style.parentNode.removeChild(style);\n    }\n  }\n  return styleTextParts.join('').trim();\n}\n\n/**\n * Split a selector separated by commas into an array in a smart way\n * @param {string} selector\n * @return {!Array<string>}\n */\nexport function splitSelectorList(selector) {\n  const parts = [];\n  let part = '';\n  for (let i = 0; i >= 0 && i < selector.length; i++) {\n    // A selector with parentheses will be one complete part\n    if (selector[i] === '(') {\n      // find the matching paren\n      const end = findMatchingParen(selector, i);\n      // push the paren block into the part\n      part += selector.slice(i, end + 1);\n      // move the index to after the paren block\n      i = end;\n    } else if (selector[i] === ',') {\n      parts.push(part);\n      part = '';\n    } else {\n      part += selector[i];\n    }\n  }\n  // catch any pieces after the last comma\n  if (part) {\n    parts.push(part);\n  }\n  return parts;\n}\n\nconst CSS_BUILD_ATTR = 'css-build';\n\n/**\n * Return the polymer-css-build \"build type\" applied to this element\n *\n * @param {!HTMLElement} element\n * @return {string} Can be \"\", \"shady\", or \"shadow\"\n */\nexport function getCssBuild(element) {\n  if (cssBuild !== undefined) {\n    return /** @type {string} */ (cssBuild);\n  }\n  if (element.__cssBuild === undefined) {\n    // try attribute first, as it is the common case\n    const attrValue = element.getAttribute(CSS_BUILD_ATTR);\n    if (attrValue) {\n      element.__cssBuild = attrValue;\n    } else {\n      const buildComment = getBuildComment(element);\n      if (buildComment !== '') {\n        // remove build comment so it is not needlessly copied into every element instance\n        removeBuildComment(element);\n      }\n      element.__cssBuild = buildComment;\n    }\n  }\n  return element.__cssBuild || '';\n}\n\n/**\n * Check if the given element, either a <template> or <style>, has been processed\n * by polymer-css-build.\n *\n * If so, then we can make a number of optimizations:\n * - polymer-css-build will decompose mixins into individual CSS Custom Properties,\n * so the ApplyShim can be skipped entirely.\n * - Under native ShadowDOM, the style text can just be copied into each instance\n * without modification\n * - If the build is \"shady\" and ShadyDOM is in use, the styling does not need\n * scoping beyond the shimming of CSS Custom Properties\n *\n * @param {!HTMLElement} element\n * @return {boolean}\n */\nexport function elementHasBuiltCss(element) {\n  return getCssBuild(element) !== '';\n}\n\n/**\n * For templates made with tagged template literals, polymer-css-build will\n * insert a comment of the form `<!--css-build:shadow-->`\n *\n * @param {!HTMLElement} element\n * @return {string}\n */\nexport function getBuildComment(element) {\n  const buildComment =\n    element.localName === 'template'\n      ? /** @type {!HTMLTemplateElement} */ (element).content.firstChild\n      : element.firstChild;\n  if (buildComment instanceof Comment) {\n    const commentParts = buildComment.textContent.trim().split(':');\n    if (commentParts[0] === CSS_BUILD_ATTR) {\n      return commentParts[1];\n    }\n  }\n  return '';\n}\n\n/**\n * Check if the css build status is optimal, and do no unneeded work.\n *\n * @param {string=} cssBuild CSS build status\n * @return {boolean} css build is optimal or not\n */\nexport function isOptimalCssBuild(cssBuild = '') {\n  // CSS custom property shim always requires work\n  if (cssBuild === '' || !nativeCssVariables) {\n    return false;\n  }\n  return nativeShadow ? cssBuild === 'shadow' : cssBuild === 'shady';\n}\n\n/**\n * @param {!HTMLElement} element\n */\nfunction removeBuildComment(element) {\n  const buildComment =\n    element.localName === 'template'\n      ? /** @type {!HTMLTemplateElement} */ (element).content.firstChild\n      : element.firstChild;\n  buildComment.parentNode.removeChild(buildComment);\n}\n", "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\n * The apply shim simulates the behavior of `@apply` proposed at\n * https://tabatkins.github.io/specs/css-apply-rule/.\n * The approach is to convert a property like this:\n *\n *    --foo: {color: red; background: blue;}\n *\n * to this:\n *\n *    --foo_-_color: red;\n *    --foo_-_background: blue;\n *\n * Then where `@apply --foo` is used, that is converted to:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background);\n *\n * This approach generally works but there are some issues and limitations.\n * Consider, for example, that somewhere *between* where `--foo` is set and used,\n * another element sets it to:\n *\n *    --foo: { border: 2px solid red; }\n *\n * We must now ensure that the color and background from the previous setting\n * do not apply. This is accomplished by changing the property set to this:\n *\n *    --foo_-_border: 2px solid red;\n *    --foo_-_color: initial;\n *    --foo_-_background: initial;\n *\n * This works but introduces one new issue.\n * Consider this setup at the point where the `@apply` is used:\n *\n *    background: orange;\n *    `@apply` --foo;\n *\n * In this case the background will be unset (initial) rather than the desired\n * `orange`. We address this by altering the property set to use a fallback\n * value like this:\n *\n *    color: var(--foo_-_color);\n *    background: var(--foo_-_background, orange);\n *    border: var(--foo_-_border);\n *\n * Note that the default is retained in the property set and the `background` is\n * the desired `orange`. This leads us to a limitation.\n *\n * Limitation 1:\n\n * Only properties in the rule where the `@apply`\n * is used are considered as default values.\n * If another rule matches the element and sets `background` with\n * less specificity than the rule in which `@apply` appears,\n * the `background` will not be set.\n *\n * Limitation 2:\n *\n * When using Polymer's `updateStyles` api, new properties may not be set for\n * `@apply` properties.\n\n*/\n\n'use strict';\n\n// prettier-ignore\nimport {forEachRule, processVariableAndFallback, rulesForStyle, toCssText, gatherStyleText} from './style-util.js';\nimport {MIXIN_MATCH, VAR_ASSIGN} from './common-regex.js';\nimport {detectMixin} from './common-utils.js';\nimport {StyleNode} from './css-parse.js'; // eslint-disable-line @typescript-eslint/no-unused-vars\n\nconst APPLY_NAME_CLEAN = /;\\s*/m;\nconst INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\nconst IMPORTANT = /\\s*!important/;\n\n// separator used between mixin-name and mixin-property-name when producing properties\n// NOTE: plain '-' may cause collisions in user styles\nconst MIXIN_VAR_SEP = '_-_';\n\n/**\n * @typedef {!Object<string, string>}\n */\nlet PropertyEntry; // eslint-disable-line @typescript-eslint/no-unused-vars\n\n/**\n * @typedef {!Object<string, boolean>}\n */\nlet DependantsEntry; // eslint-disable-line @typescript-eslint/no-unused-vars\n\n/** @typedef {{\n *    properties: PropertyEntry,\n *    dependants: DependantsEntry\n * }}\n */\nlet MixinMapEntry; // eslint-disable-line @typescript-eslint/no-unused-vars\n\n// map of mixin to property names\n// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}\nclass MixinMap {\n  constructor() {\n    /** @type {!Object<string, !MixinMapEntry>} */\n    this._map = {};\n  }\n  /**\n   * @param {string} name\n   * @param {!PropertyEntry} props\n   */\n  set(name, props) {\n    name = name.trim();\n    this._map[name] = {\n      properties: props,\n      dependants: {},\n    };\n  }\n  /**\n   * @param {string} name\n   * @return {MixinMapEntry}\n   */\n  get(name) {\n    name = name.trim();\n    return this._map[name] || null;\n  }\n}\n\n/**\n * Callback for when an element is marked invalid\n * @type {?function(string)}\n */\nlet invalidCallback = null;\n\n/** @unrestricted */\nclass ApplyShim {\n  constructor() {\n    /** @type {?string} */\n    this._currentElement = null;\n    /** @type {HTMLMetaElement} */\n    this._measureElement = null;\n    this._map = new MixinMap();\n  }\n  /**\n   * return true if `cssText` contains a mixin definition or consumption\n   * @param {string} cssText\n   * @return {boolean}\n   */\n  detectMixin(cssText) {\n    return detectMixin(cssText);\n  }\n\n  /**\n   * Gather styles into one style for easier processing\n   * @param {!HTMLTemplateElement} template\n   * @return {HTMLStyleElement}\n   */\n  gatherStyles(template) {\n    const styleText = gatherStyleText(template.content);\n    if (styleText) {\n      const style = /** @type {!HTMLStyleElement} */ (document.createElement(\n        'style'\n      ));\n      style.textContent = styleText;\n      template.content.insertBefore(style, template.content.firstChild);\n      return style;\n    }\n    return null;\n  }\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n  transformTemplate(template, elementName) {\n    if (template._gatheredStyle === undefined) {\n      template._gatheredStyle = this.gatherStyles(template);\n    }\n    /** @type {HTMLStyleElement} */\n    const style = template._gatheredStyle;\n    return style ? this.transformStyle(style, elementName) : null;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @param {string} elementName\n   * @return {StyleNode}\n   */\n  transformStyle(style, elementName = '') {\n    let ast = rulesForStyle(style);\n    this.transformRules(ast, elementName);\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {!HTMLStyleElement} style\n   * @return {StyleNode}\n   */\n  transformCustomStyle(style) {\n    let ast = rulesForStyle(style);\n    forEachRule(ast, (rule) => {\n      if (rule['selector'] === ':root') {\n        rule['selector'] = 'html';\n      }\n      this.transformRule(rule);\n    });\n    style.textContent = toCssText(ast);\n    return ast;\n  }\n  /**\n   * @param {StyleNode} rules\n   * @param {string} elementName\n   */\n  transformRules(rules, elementName) {\n    this._currentElement = elementName;\n    forEachRule(rules, (r) => {\n      this.transformRule(r);\n    });\n    this._currentElement = null;\n  }\n  /**\n   * @param {!StyleNode} rule\n   */\n  transformRule(rule) {\n    rule['cssText'] = this.transformCssText(rule['parsedCssText'], rule);\n    // :root was only used for variable assignment in property shim,\n    // but generates invalid selectors with real properties.\n    // replace with `:host > *`, which serves the same effect\n    if (rule['selector'] === ':root') {\n      rule['selector'] = ':host > *';\n    }\n  }\n  /**\n   * @param {string} cssText\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n  transformCssText(cssText, rule) {\n    // produce variables\n    cssText = cssText.replace(\n      VAR_ASSIGN,\n      (matchText, propertyName, valueProperty, valueMixin) =>\n        this._produceCssProperties(\n          matchText,\n          propertyName,\n          valueProperty,\n          valueMixin,\n          rule\n        )\n    );\n    // consume mixins\n    return this._consumeCssProperties(cssText, rule);\n  }\n  /**\n   * @param {string} property\n   * @return {string}\n   */\n  _getInitialValueForProperty(property) {\n    if (!this._measureElement) {\n      this._measureElement = /** @type {HTMLMetaElement} */ (document.createElement(\n        'meta'\n      ));\n      this._measureElement.setAttribute('apply-shim-measure', '');\n      this._measureElement.style.all = 'initial';\n      document.head.appendChild(this._measureElement);\n    }\n    return window\n      .getComputedStyle(this._measureElement)\n      .getPropertyValue(property);\n  }\n  /**\n   * Walk over all rules before this rule to find fallbacks for mixins\n   *\n   * @param {!StyleNode} startRule\n   * @return {!Object}\n   */\n  _fallbacksFromPreviousRules(startRule) {\n    // find the \"top\" rule\n    let topRule = startRule;\n    while (topRule['parent']) {\n      topRule = topRule['parent'];\n    }\n    const fallbacks = {};\n    let seenStartRule = false;\n    forEachRule(topRule, (r) => {\n      // stop when we hit the input rule\n      seenStartRule = seenStartRule || r === startRule;\n      if (seenStartRule) {\n        return;\n      }\n      // NOTE: Only matching selectors are \"safe\" for this fallback processing\n      // It would be prohibitive to run `matchesSelector()` on each selector,\n      // so we cheat and only check if the same selector string is used, which\n      // guarantees things like specificity matching\n      if (r['selector'] === startRule['selector']) {\n        Object.assign(fallbacks, this._cssTextToMap(r['parsedCssText']));\n      }\n    });\n    return fallbacks;\n  }\n  /**\n   * replace mixin consumption with variable consumption\n   * @param {string} text\n   * @param {!StyleNode=} rule\n   * @return {string}\n   */\n  _consumeCssProperties(text, rule) {\n    /** @type {Array} */\n    let m = null;\n    // loop over text until all mixins with defintions have been applied\n    while ((m = MIXIN_MATCH.exec(text))) {\n      let matchText = m[0];\n      let mixinName = m[1];\n      let idx = m.index;\n      // collect properties before apply to be \"defaults\" if mixin might override them\n      // match includes a \"prefix\", so find the start and end positions of @apply\n      let applyPos = idx + matchText.indexOf('@apply');\n      let afterApplyPos = idx + matchText.length;\n      // find props defined before this @apply\n      let textBeforeApply = text.slice(0, applyPos);\n      let textAfterApply = text.slice(afterApplyPos);\n      let defaults = rule ? this._fallbacksFromPreviousRules(rule) : {};\n      Object.assign(defaults, this._cssTextToMap(textBeforeApply));\n      let replacement = this._atApplyToCssProperties(mixinName, defaults);\n      // use regex match position to replace mixin, keep linear processing time\n      text = `${textBeforeApply}${replacement}${textAfterApply}`;\n      // move regex search to _after_ replacement\n      MIXIN_MATCH.lastIndex = idx + replacement.length;\n    }\n    return text;\n  }\n  /**\n   * produce variable consumption at the site of mixin consumption\n   * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))\n   * Example:\n   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)\n   *\n   * @param {string} mixinName\n   * @param {Object} fallbacks\n   * @return {string}\n   */\n  _atApplyToCssProperties(mixinName, fallbacks) {\n    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\n    let vars = [];\n    let mixinEntry = this._map.get(mixinName);\n    // if we depend on a mixin before it is created\n    // make a sentinel entry in the map to add this element as a dependency for when it is defined.\n    if (!mixinEntry) {\n      this._map.set(mixinName, {});\n      mixinEntry = this._map.get(mixinName);\n    }\n    if (mixinEntry) {\n      if (this._currentElement) {\n        mixinEntry.dependants[this._currentElement] = true;\n      }\n      let p, parts, f;\n      const properties = mixinEntry.properties;\n      for (p in properties) {\n        f = fallbacks && fallbacks[p];\n        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];\n        if (f) {\n          parts.push(',', f.replace(IMPORTANT, ''));\n        }\n        parts.push(')');\n        if (IMPORTANT.test(properties[p])) {\n          parts.push(' !important');\n        }\n        vars.push(parts.join(''));\n      }\n    }\n    return vars.join('; ');\n  }\n\n  /**\n   * @param {string} property\n   * @param {string} value\n   * @return {string}\n   */\n  _replaceInitialOrInherit(property, value) {\n    let match = INITIAL_INHERIT.exec(value);\n    if (match) {\n      if (match[1]) {\n        // initial\n        // replace `initial` with the concrete initial value for this property\n        value = this._getInitialValueForProperty(property);\n      } else {\n        // inherit\n        // with this purposfully illegal value, the variable will be invalid at\n        // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)\n        // and for inheriting values, will behave similarly\n        // we cannot support the same behavior for non inheriting values like 'border'\n        value = 'apply-shim-inherit';\n      }\n    }\n    return value;\n  }\n\n  /**\n   * \"parse\" a mixin definition into a map of properties and values\n   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')\n   * @param {string} text\n   * @param {boolean=} replaceInitialOrInherit\n   * @return {!Object<string, string>}\n   */\n  _cssTextToMap(text, replaceInitialOrInherit = false) {\n    let props = text.split(';');\n    let property, value;\n    let out = {};\n    for (let i = 0, p, sp; i < props.length; i++) {\n      p = props[i];\n      if (p) {\n        sp = p.split(':');\n        // ignore lines that aren't definitions like @media\n        if (sp.length > 1) {\n          property = sp[0].trim();\n          // some properties may have ':' in the value, like data urls\n          value = sp.slice(1).join(':');\n          if (replaceInitialOrInherit) {\n            value = this._replaceInitialOrInherit(property, value);\n          }\n          out[property] = value;\n        }\n      }\n    }\n    return out;\n  }\n\n  /**\n   * @param {MixinMapEntry} mixinEntry\n   */\n  _invalidateMixinEntry(mixinEntry) {\n    if (!invalidCallback) {\n      return;\n    }\n    for (let elementName in mixinEntry.dependants) {\n      if (elementName !== this._currentElement) {\n        invalidCallback(elementName);\n      }\n    }\n  }\n\n  /**\n   * @param {string} matchText\n   * @param {string} propertyName\n   * @param {?string} valueProperty\n   * @param {?string} valueMixin\n   * @param {!StyleNode} rule\n   * @return {string}\n   */\n  _produceCssProperties(\n    matchText,\n    propertyName,\n    valueProperty,\n    valueMixin,\n    rule\n  ) {\n    // handle case where property value is a mixin\n    if (valueProperty) {\n      // form: --mixin2: var(--mixin1), where --mixin1 is in the map\n      processVariableAndFallback(valueProperty, (prefix, value) => {\n        if (value && this._map.get(value)) {\n          valueMixin = `@apply ${value};`;\n        }\n      });\n    }\n    if (!valueMixin) {\n      return matchText;\n    }\n    let mixinAsProperties = this._consumeCssProperties('' + valueMixin, rule);\n    let prefix = matchText.slice(0, matchText.indexOf('--'));\n    // `initial` and `inherit` as properties in a map should be replaced because\n    // these keywords are eagerly evaluated when the mixin becomes CSS Custom Properties,\n    // and would set the variable value, rather than carry the keyword to the `var()` usage.\n    let mixinValues = this._cssTextToMap(mixinAsProperties, true);\n    let combinedProps = mixinValues;\n    let mixinEntry = this._map.get(propertyName);\n    let oldProps = mixinEntry && mixinEntry.properties;\n    if (oldProps) {\n      // NOTE: since we use mixin, the map of properties is updated here\n      // and this is what we want.\n      combinedProps = Object.assign(Object.create(oldProps), mixinValues);\n    } else {\n      this._map.set(propertyName, combinedProps);\n    }\n    let out = [];\n    let p, v;\n    // set variables defined by current mixin\n    let needToInvalidate = false;\n    for (p in combinedProps) {\n      v = mixinValues[p];\n      // if property not defined by current mixin, set initial\n      if (v === undefined) {\n        v = 'initial';\n      }\n      if (oldProps && !(p in oldProps)) {\n        needToInvalidate = true;\n      }\n      out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);\n    }\n    if (needToInvalidate) {\n      this._invalidateMixinEntry(mixinEntry);\n    }\n    if (mixinEntry) {\n      mixinEntry.properties = combinedProps;\n    }\n    // because the mixinMap is global, the mixin might conflict with\n    // a different scope's simple variable definition:\n    // Example:\n    // some style somewhere:\n    // --mixin1:{ ... }\n    // --mixin2: var(--mixin1);\n    // some other element:\n    // --mixin1: 10px solid red;\n    // --foo: var(--mixin1);\n    // In this case, we leave the original variable definition in place.\n    if (valueProperty) {\n      prefix = `${matchText};${prefix}`;\n    }\n    return `${prefix}${out.join('; ')};`;\n  }\n}\n\n/* exports */\n/* eslint-disable no-self-assign */\nApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;\nApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;\nApplyShim.prototype['transformCustomStyle'] =\n  ApplyShim.prototype.transformCustomStyle;\nApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;\nApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;\nApplyShim.prototype['transformTemplate'] =\n  ApplyShim.prototype.transformTemplate;\nApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;\n/* eslint-enable no-self-assign */\nObject.defineProperty(ApplyShim.prototype, 'invalidCallback', {\n  /** @return {?function(string)} */\n  get() {\n    return invalidCallback;\n  },\n  /** @param {?function(string)} cb */\n  set(cb) {\n    invalidCallback = cb;\n  },\n});\n\nexport default ApplyShim;\n", "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {MIXIN_MATCH, VAR_ASSIGN} from './common-regex.js';\n\n/**\n * @param {Element} element\n * @param {Object=} properties\n */\nexport function updateNativeProperties(element, properties) {\n  // remove previous properties\n  for (let p in properties) {\n    // NOTE: for bc with shim, don't apply null values.\n    if (p === null) {\n      element.style.removeProperty(p);\n    } else {\n      element.style.setProperty(p, properties[p]);\n    }\n  }\n}\n\n/**\n * @param {Element} element\n * @param {string} property\n * @return {string}\n */\nexport function getComputedStyleValue(element, property) {\n  /**\n   * @const {string}\n   */\n  const value = window.getComputedStyle(element).getPropertyValue(property);\n  if (!value) {\n    return '';\n  } else {\n    return value.trim();\n  }\n}\n\n/**\n * return true if `cssText` contains a mixin definition or consumption\n * @param {string} cssText\n * @return {boolean}\n */\nexport function detectMixin(cssText) {\n  const has = MIXIN_MATCH.test(cssText) || VAR_ASSIGN.test(cssText);\n  // reset state of the regexes\n  MIXIN_MATCH.lastIndex = 0;\n  VAR_ASSIGN.lastIndex = 0;\n  return has;\n}\n", "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\n/**\n * @const {!Object<string, !HTMLTemplateElement>}\n */\nconst templateMap = {};\nexport default templateMap;\n", "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\nimport templateMap from './template-map.js';\nimport {StyleNode} from './css-parse.js'; // eslint-disable-line @typescript-eslint/no-unused-vars\n\n/*\n * Utilities for handling invalidating apply-shim mixins for a given template.\n *\n * The invalidation strategy involves keeping track of the \"current\" version of a template's mixins, and updating that count when a mixin is invalidated.\n * The template\n */\n\n/** @const {string} */\nconst CURRENT_VERSION = '_applyShimCurrentVersion';\n\n/** @const {string} */\nconst NEXT_VERSION = '_applyShimNextVersion';\n\n/** @const {string} */\nconst VALIDATING_VERSION = '_applyShimValidatingVersion';\n\n/**\n * @const {Promise<void>}\n */\nconst promise = Promise.resolve();\n\n/**\n * @param {string} elementName\n */\nexport function invalidate(elementName) {\n  let template = templateMap[elementName];\n  if (template) {\n    invalidateTemplate(template);\n  }\n}\n\n/**\n * This function can be called multiple times to mark a template invalid\n * and signal that the style inside must be regenerated.\n *\n * Use `startValidatingTemplate` to begin an asynchronous validation cycle.\n * During that cycle, call `templateIsValidating` to see if the template must\n * be revalidated\n * @param {HTMLTemplateElement} template\n */\nexport function invalidateTemplate(template) {\n  // default the current version to 0\n  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;\n  // ensure the \"validating for\" flag exists\n  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;\n  // increment the next version\n  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;\n}\n\n/**\n * @param {string} elementName\n * @return {boolean}\n */\nexport function isValid(elementName) {\n  let template = templateMap[elementName];\n  if (template) {\n    return templateIsValid(template);\n  }\n  return true;\n}\n\n/**\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\nexport function templateIsValid(template) {\n  return template[CURRENT_VERSION] === template[NEXT_VERSION];\n}\n\n/**\n * @param {string} elementName\n * @return {boolean}\n */\nexport function isValidating(elementName) {\n  let template = templateMap[elementName];\n  if (template) {\n    return templateIsValidating(template);\n  }\n  return false;\n}\n\n/**\n * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.\n * If false, the template must be validated.\n * @param {HTMLTemplateElement} template\n * @return {boolean}\n */\nexport function templateIsValidating(template) {\n  return (\n    !templateIsValid(template) &&\n    template[VALIDATING_VERSION] === template[NEXT_VERSION]\n  );\n}\n\n/**\n * the template is marked as `validating` for one microtask so that all instances\n * found in the tree crawl of `applyStyle` will update themselves,\n * but the template will only be updated once.\n * @param {string} elementName\n */\nexport function startValidating(elementName) {\n  let template = templateMap[elementName];\n  startValidatingTemplate(template);\n}\n\n/**\n * Begin an asynchronous invalidation cycle.\n * This should be called after every validation of a template\n *\n * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`\n * @param {HTMLTemplateElement} template\n */\nexport function startValidatingTemplate(template) {\n  // remember that the current \"next version\" is the reason for this validation cycle\n  template[VALIDATING_VERSION] = template[NEXT_VERSION];\n  // however, there only needs to be one async task to clear the counters\n  if (!template._validating) {\n    template._validating = true;\n    promise.then(function () {\n      // sync the current version to let future invalidations cause a refresh cycle\n      template[CURRENT_VERSION] = template[NEXT_VERSION];\n      template._validating = false;\n    });\n  }\n}\n\n/**\n * @return {boolean}\n */\nexport function elementsAreInvalid() {\n  for (let elementName in templateMap) {\n    let template = templateMap[elementName];\n    if (!templateIsValid(template)) {\n      return true;\n    }\n  }\n  return false;\n}\n", "/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport ApplyShim from '../src/apply-shim.js';\nimport templateMap from '../src/template-map.js';\n// prettier-ignore\nimport {getIsExtends, toCssText, elementHasBuiltCss} from '../src/style-util.js';\nimport * as ApplyShimUtils from '../src/apply-shim-utils.js';\n// prettier-ignore\nimport {getComputedStyleValue, updateNativeProperties} from '../src/common-utils.js';\nimport {CustomStyleInterfaceInterface} from '../src/custom-style-interface.js'; // eslint-disable-line @typescript-eslint/no-unused-vars\n// prettier-ignore\nimport {nativeCssVariables, nativeShadow, cssBuild, disableRuntime} from '../src/style-settings.js';\n\n/** @const {ApplyShim} */\nconst applyShim = new ApplyShim();\n\nclass ApplyShimInterface {\n  constructor() {\n    /** @type {?CustomStyleInterfaceInterface} */\n    this.customStyleInterface = null;\n    applyShim['invalidCallback'] = ApplyShimUtils.invalidate;\n  }\n  ensure() {\n    if (this.customStyleInterface) {\n      return;\n    }\n    if (window.ShadyCSS.CustomStyleInterface) {\n      this.customStyleInterface = /** @type {!CustomStyleInterfaceInterface} */ (window\n        .ShadyCSS.CustomStyleInterface);\n      this.customStyleInterface['transformCallback'] = (style) => {\n        applyShim.transformCustomStyle(style);\n      };\n      this.customStyleInterface['validateCallback'] = () => {\n        requestAnimationFrame(() => {\n          if (this.customStyleInterface['enqueued']) {\n            this.flushCustomStyles();\n          }\n        });\n      };\n    }\n  }\n  /**\n   * @param {!HTMLTemplateElement} template\n   * @param {string} elementName\n   */\n  prepareTemplate(template, elementName) {\n    this.ensure();\n    if (elementHasBuiltCss(template)) {\n      return;\n    }\n    templateMap[elementName] = template;\n    let ast = applyShim.transformTemplate(template, elementName);\n    // save original style ast to use for revalidating instances\n    template['_styleAst'] = ast;\n  }\n  flushCustomStyles() {\n    this.ensure();\n    if (!this.customStyleInterface) {\n      return;\n    }\n    let styles = this.customStyleInterface['processStyles']();\n    if (!this.customStyleInterface['enqueued']) {\n      return;\n    }\n    for (let i = 0; i < styles.length; i++) {\n      let cs = styles[i];\n      let style = this.customStyleInterface['getStyleForCustomStyle'](cs);\n      if (style) {\n        applyShim.transformCustomStyle(style);\n      }\n    }\n    this.customStyleInterface['enqueued'] = false;\n  }\n  /**\n   * @param {HTMLElement} element\n   * @param {Object=} properties\n   */\n  styleSubtree(element, properties) {\n    this.ensure();\n    if (properties) {\n      updateNativeProperties(element, properties);\n    }\n    if (element.shadowRoot) {\n      this.styleElement(element);\n      let shadowChildren =\n        /** @type {!ParentNode} */ (element.shadowRoot).children ||\n        element.shadowRoot.childNodes;\n      for (let i = 0; i < shadowChildren.length; i++) {\n        this.styleSubtree(/** @type {HTMLElement} */ (shadowChildren[i]));\n      }\n    } else {\n      let children = element.children || element.childNodes;\n      for (let i = 0; i < children.length; i++) {\n        this.styleSubtree(/** @type {HTMLElement} */ (children[i]));\n      }\n    }\n  }\n  /**\n   * @param {HTMLElement} element\n   */\n  styleElement(element) {\n    this.ensure();\n    let {is} = getIsExtends(element);\n    let template = templateMap[is];\n    if (template && elementHasBuiltCss(template)) {\n      return;\n    }\n    if (template && !ApplyShimUtils.templateIsValid(template)) {\n      // only revalidate template once\n      if (!ApplyShimUtils.templateIsValidating(template)) {\n        this.prepareTemplate(template, is);\n        ApplyShimUtils.startValidatingTemplate(template);\n      }\n      // update this element instance\n      let root = element.shadowRoot;\n      if (root) {\n        let style = /** @type {HTMLStyleElement} */ (root.querySelector(\n          'style'\n        ));\n        if (style) {\n          // reuse the template's style ast, it has all the original css text\n          style['__cssRules'] = template['_styleAst'];\n          style.textContent = toCssText(template['_styleAst']);\n        }\n      }\n    }\n  }\n  /**\n   * @param {Object=} properties\n   */\n  styleDocument(properties) {\n    this.ensure();\n    this.styleSubtree(document.body, properties);\n  }\n}\n\nif (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {\n  const applyShimInterface = new ApplyShimInterface();\n  let CustomStyleInterface =\n    window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;\n\n  /** @suppress {duplicate} */\n  window.ShadyCSS = {\n    /**\n     * @param {!HTMLTemplateElement} template\n     * @param {string} elementName\n     * @param {string=} elementExtends\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    prepareTemplate(template, elementName, elementExtends) {\n      applyShimInterface.flushCustomStyles();\n      applyShimInterface.prepareTemplate(template, elementName);\n    },\n\n    /**\n     * @param {!HTMLTemplateElement} template\n     * @param {string} elementName\n     * @param {string=} elementExtends\n     */\n    prepareTemplateStyles(template, elementName, elementExtends) {\n      window.ShadyCSS.prepareTemplate(template, elementName, elementExtends);\n    },\n\n    /**\n     * @param {!HTMLTemplateElement} template\n     * @param {string} elementName\n     */\n    prepareTemplateDom(template, elementName) {}, // eslint-disable-line @typescript-eslint/no-unused-vars\n\n    /**\n     * @param {!HTMLElement} element\n     * @param {Object=} properties\n     */\n    styleSubtree(element, properties) {\n      applyShimInterface.flushCustomStyles();\n      applyShimInterface.styleSubtree(element, properties);\n    },\n\n    /**\n     * @param {!HTMLElement} element\n     */\n    styleElement(element) {\n      applyShimInterface.flushCustomStyles();\n      applyShimInterface.styleElement(element);\n    },\n\n    /**\n     * @param {Object=} properties\n     */\n    styleDocument(properties) {\n      applyShimInterface.flushCustomStyles();\n      applyShimInterface.styleDocument(properties);\n    },\n\n    /**\n     * @param {Element} element\n     * @param {string} property\n     * @return {string}\n     */\n    getComputedStyleValue(element, property) {\n      return getComputedStyleValue(element, property);\n    },\n\n    flushCustomStyles() {\n      applyShimInterface.flushCustomStyles();\n    },\n\n    nativeCss: nativeCssVariables,\n    nativeShadow: nativeShadow,\n    cssBuild: cssBuild,\n    disableRuntime: disableRuntime,\n  };\n\n  if (CustomStyleInterface) {\n    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;\n  }\n}\n\nwindow.ShadyCSS.ApplyShim = applyShim;\n"],
  "mappings": "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",
  "names": ["nativeShadow", "window", "nativeCssVariables_", "calcCssVariables", "settings", "shimcssproperties", "navigator", "userAgent", "match", "CSS", "supports", "cssBuild", "ShadyCSS", "undefined", "disableRuntime", "nativeCss", "nativeCssVariables", "constructor", "StyleNode", "parse", "text", "replace", "RX$$module$src$css_parse.comments", "RX$$module$src$css_parse.port", "root", "length", "n", "i", "l", "OPEN_BRACE", "p", "previous", "push", "CLOSE_BRACE", "parseCss", "node", "t", "substring", "trim", "_expandUnicodeEscapes", "RX$$module$src$css_parse.multipleSpaces", "lastIndexOf", "s", "indexOf", "AT_START", "MEDIA_START", "types$$module$src$css_parse.MEDIA_RULE", "RX$$module$src$css_parse.keyframesRule", "types$$module$src$css_parse.KEYFRAMES_RULE", "split", "pop", "VAR_START", "types$$module$src$css_parse.MIXIN_RULE", "types$$module$src$css_parse.STYLE_RULE", "r$", "r", "code", "repeat", "stringify", "preserveProperties", "cssText", "rules", "RX$$module$src$css_parse.customProp", "RX$$module$src$css_parse.mixinProp", "RX$$module$src$css_parse.mixinApply", "RX$$module$src$css_parse.varApply", "STYLE_RULE", "KEYFRAMES_RULE", "MEDIA_RULE", "MIXIN_RULE", "comments", "port", "customProp", "mixinProp", "mixinApply", "varApply", "keyframesRule", "multipleSpaces", "VAR_ASSIGN", "MIXIN_MATCH", "MEDIA_MATCH", "styleTextSet", "Set", "toCssText", "rulesForStyle", "style", "textContent", "forEachRule", "styleRuleCallback", "keyframesRuleCallback", "onlyActiveRules", "skipRules", "type", "matchMedia", "matches", "processVariableAndFallback", "str", "callback", "start", "level", "inner", "end", "prefix", "suffix", "comma", "value", "fallback", "getCssBuild", "element", "__cssBuild", "attrValue", "getAttribute", "CSS_BUILD_ATTR", "buildComment", "localName", "content", "firstChild", "Comment", "commentParts", "parentNode", "removeChild", "APPLY_NAME_CLEAN", "INITIAL_INHERIT", "IMPORTANT", "MixinMap", "_map", "set", "name", "props", "properties", "dependants", "get", "invalidCallback", "ApplyShim", "_measureElement", "_currentElement", "detectMixin", "has", "test", "lastIndex", "transformTemplate", "template", "elementName", "_gatheredStyle", "styleTextParts", "styles", "querySelectorAll", "hasAttribute", "scopingAttribute", "add", "newStyle", "document", "createElement", "setAttribute", "head", "appendChild", "join", "styleText", "insertBefore", "transformStyle", "ast", "transformRules", "transformCustomStyle", "rule", "transformRule", "transformCssText", "matchText", "propertyName", "valueProperty", "valueMixin", "_produceCssProperties", "_consumeCssProperties", "_fallbacksFromPreviousRules", "startRule", "topRule", "fallbacks", "seenStartRule", "Object", "assign", "_cssTextToMap", "m", "exec", "mixinName", "idx", "index", "textBeforeApply", "slice", "textAfterApply", "defaults", "_atApplyToCssProperties", "vars", "mixinEntry", "f", "parts", "MIXIN_VAR_SEP", "replacement", "replaceInitialOrInherit", "property", "out", "sp", "_replaceInitialOrInherit", "all", "getComputedStyle", "getPropertyValue", "_invalidateMixinEntry", "mixinAsProperties", "combinedProps", "mixinValues", "oldProps", "create", "needToInvalidate", "v", "prototype", "defineProperty", "cb", "templateMap", "promise", "Promise", "resolve", "invalidate", "CURRENT_VERSION", "VALIDATING_VERSION", "NEXT_VERSION", "templateIsValid", "startValidatingTemplate", "_validating", "then", "applyShim", "ApplyShimInterface", "customStyleInterface", "ensure", "CustomStyleInterface", "requestAnimationFrame", "flushCustomStyles", "prepareTemplate", "styleSubtree", "removeProperty", "setProperty", "shadowRoot", "styleElement", "shadowChildren", "children", "childNodes", "is", "querySelector", "styleDocument", "body", "ScopingShim", "applyShimInterface", "prepareTemplateStyles", "elementExtends", "prepareTemplateDom", "getComputedStyleValue"]
}
